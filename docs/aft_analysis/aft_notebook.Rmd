---
title: "Notes for AFT Article"
output: html_document
date:  '`r Sys.Date()`'
---

```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(echo = F, warning = F, message = F)
aft <- read_csv("../../data/aft.csv")
tmi <- read_csv("../../data/tmi.csv")
atu <- read_csv("../../data/atu.csv")
```

# Cleaning

Additional cleaning of datasets needed:
-   Clean up tale names regex in `atu`
-   Finish ATU sequences


# Exploratory analysis: What's in the AFT corpus?

## Tale Types

-   Proportion of ATU represented by `aft`

```{r unmatched_in_atu, eval=FALSE, include=FALSE}

tst <-
  aft %>%
  anti_join(atu %>% select(chapter:tale_name), by = "atu_id") %>%
  distinct()

```

```{r merge_aft_atu}

# Merge AFT with ATU and filter unmatched items from AFT

aft_in_atu <-
  aft %>%
  select(atu_id) %>%
  mutate(in_aft = T) %>%
  full_join(atu %>% select(chapter:tale_name), by = "atu_id") %>%
  filter(!is.na(chapter)) %>% # remove items in AFT but not ATU
  mutate(in_aft = ifelse(!is.na(in_aft),T,F)) %>%
  group_by(atu_id,chapter,division,sub_division,tale_name) %>%
  summarize(n_tales = sum(in_aft))

```

### By ATU Chapter/Division

Summary stats by ATU chapter:

```{r}
library(formattable)

aft_in_atu %>%
  mutate(with_tale = n_tales > 0) %>%
  group_by(chapter) %>%
  summarize(
    n_types = n_distinct(atu_id),
    n_types_with_tale = sum(with_tale),
    n_tales = sum(n_tales)
  ) %>%
  mutate(
    pct_with_tales = round(n_types_with_tale / n_types * 100, digits = 1),
    tales_per = round(n_tales / n_types_with_tale, digits = 1)
  ) %>%
  arrange(desc(tales_per)) %>%
  select(-n_types_with_tale) %>%
  formattable(
    list(
      n_tales = color_bar("#1BB6AFFF"),
      # n_types_with_tale = color_bar("#EC921DFF"),
      n_types = color_bar("#1BB6AFFF"),
      pct_with_tales = color_tile("transparent", "#EF562AFF"),
      tales_per = color_tile("transparent", "#EF562AFF")
    )
  )


```

The treemap below shows the nested sets of the ATU into which AFT texts fall, by `chapter`, `division`, and `sub_division`.

```{r}

aft_tree <-
  aft_in_atu %>%
  group_by(chapter,division) %>%
  summarize(
    n_types = n_distinct(atu_id),
    n_tales = sum(n_tales)
  ) %>%
  filter(!is.na(division)) %>%
  rename(parent = chapter, labels = division) %>%
  bind_rows(
    aft_in_atu %>%
    filter(!is.na(division)) %>%
    group_by(chapter) %>%
    summarize(
      n_types = n_distinct(atu_id),
      n_tales = sum(n_tales)
    ) %>%
    mutate(parent = "root") %>%
    rename(labels = chapter)
  ) %>%
  bind_rows(
    aft_in_atu %>%
    filter(!is.na(division)) %>%
    group_by(division, sub_division) %>%
    summarize(
      n_types = n_distinct(atu_id),
      n_tales = sum(n_tales)
    ) %>%
    rename(parent = division, labels = sub_division)
  ) # %>%
  # bind_rows(
  #   aft_in_atu %>%
  #   filter(!is.na(division)) %>%
  #   group_by(sub_division, tale_name) %>%
  #   summarize(
  #     n_types = n_distinct(atu_id),
  #     n_tales = sum(n_tales)
  #   ) %>%
  #   rename(parent = sub_division, labels = tale_name)
  # )

plotly::plot_ly(
  aft_tree,
  type = 'treemap',
  labels = ~labels,
  parents = ~parent,
  values = ~n_tales
)

```

## Textual Content

### Entities

To do:

- Find a well performing model for NER (cf. https://huggingface.co/flair/ner-english-ontonotes-fast, https://huggingface.co/stanfordnlp/stanza-en)
- Find a way to label the name of a main character (example Miller, prince, etc.) as more than simply a noun
- Pull out subject and predicate from sentence.  Explore verbs related to subjects.

### Common phrases 

```{python}

```

- TextRank
- collocation/word frequency

### Topic modeling

- Define cleaning tasks and stop words to improve topic models performance; right now they are too close together, with a few main clusters of topics that are difficult to distinguish

# Motif identification?

Notes/questions from Sándor:

Atu markup segments motif abstracts
TMI defines motifs by 1-2 sentences
Relate words in both, cooccurrence
Relate this cooccurrence matrix to AFT types

Given three resources, each providing a fragment of the problem. Is this enough for a solution? TMI: a list of motif names, but not definitions. ATU: a list of motif strings aka tale types, built from TMI items. AFT: a selection of tale types as exemplification for the ATU, with frequent enough examples for some of the motif strings in some of the 8 topical genres.

8 genres with frequent enough examples of respective, typical motif strings built from the LEGO kit called the TMI. X samples of text with inherent motif strings for backbones; backbones as motif-based markup; motif “definition”, all three in running text. Motif is a 1-2 sentence summary of some recurrent content element with a function in the plot, relating actors in situations with tools of their resolution. Tale type is an abstract, linking situations in shorthand, from setting through complication to resolution. Can real motifs from typical texts be extracted by means of theoretical strings of theoretical motifs? Is there a way to validate the TMI by automatic means, like in an ML experiment, out of many? Are these three resources enough to reach our goal?

Match between label (TMI) and ill-bounded/demarcated text fragment over an AFT set. Can we find a transformation which converts the set of segments into the label? By means of abstraction/abstracting. Text summarisation in Python and DL available. Reverse problem: how to arrive at text set from label as string. Depends on set size and topic composition, possibly a set of particular mixes.

Given a label and a set of text segments to arrive at that label by DL. Which architecture/method yields the best heuristics? Approximate transformation by back propagation (?). Consult JEK.

Add MFTL. LRRH. Custom-built for experimentation, for researchers with interest in the intersection of data science and folk tale studies. For work in progress.

For every motif in string, correlation between TMI label and ATU segment content vs ATU segment content and AFT segment set, manually marked up.

Convert type sample to robust conceptual equivalent.

- Do you think you could build a 3-d matrix (tensor) from the trilogy, or respective- motifs and types constrained by the AFT? E.g. axis x would be the TMI-based motifs aka concept strings; axis y would be ATU types aka motif strings; and axis z would be the AFT where some types are exemplified by text sets. 

Then we could expose this tensor to all kinds of analysis, including DL by CNN (Johan's favourite), or co-clustering (my bet).

As food for thought, consider this as a working hypothesis: "a motif is a multiple co-occurrence of concept strings anchored in the trilogy". Whatever the outcome, negative or positive, the hypothesis can be tested, and we could learn if this definition can be falsified. 

Plus look at the visuals from co-clustering results for 'multiple cooccurrence' as a GS query. Just 150 hits which sounds quite promising for explaining the idea by references from multiple domains, ie methodological cross-pollination.

By concept strings in the TMI I would expect some normalization of word forms to concepts just like eg Propp's characters, actions/functions, situations etc. There we could perhaps look into ontologies if they exist. Thierry Declerck's work comes to mind.
